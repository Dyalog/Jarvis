{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Note</p> <p>This documentation continues to be a work in progress.  General usage and settings references are complete. Frequent updates will be forthcoming as additional sections are completed.</p> <p>Jarvis is an HTTP server that makes it easy to create a web service to provide access to your APL code from the web or a local network.</p> <p>Any client program written in any language on any platform that can process HTTP requests can access  a Jarvis-based web service. This vastly increases the potential audience for your application - the client can be a standard web browser, a phone app, a browser-based app, or a custom client written in a language like Python or C# and yes, even APL.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>The name Jarvis is a pseudo-acronym for JSON and REST Service (\"vice\" becomes \"vis\") and was also inspired by J.A.R.V.I.S. (Just A Rather Very Intelligent System) from the Marvel Cinematic Universe. </p> <p>Formatting Note: You may notice that the name \"Jarvis\" is formatted in two, possibly three, different ways:</p> <ul> <li>Jarvis refers Jarvis as an abstract idea</li> <li><code>Jarvis</code> refers to the Dyalog APL Jarvis class</li> <li>Jarvis (unadorned) is probably the author's mistake for not having formatted the occurrence as one of the above.</li> </ul>"},{"location":"#design-goals","title":"Design Goals","text":"<p>Jarvis is designed to make it very easy for an APLer to create web services without requiring in-depth knowledge of web service frameworks. In designing Jarvis we've attempted to</p> <ul> <li>Make Jarvis' default behavior simple and applicable to many use cases</li> <li>Make few assumptions about what the user actually needs to do</li> <li>Provide hooks to allow the user to tailor or extend Jarvis' behavior if needed</li> </ul>"},{"location":"#create-an-apl-web-service-in-5-minutes","title":"Create an APL Web Service in 5 Minutes","text":"<p>If you know how to write a monadic, result-returning APL function, you're ready to run your first Jarvis-based web service.  Here's how:</p> <ol> <li> <p>If you already have a copy of the <code>Jarvis</code> class, skip to step 3.  Otherwise, load the <code>HttpCommand</code> utility so that we can download a copy of Jarvis and also use <code>HttpCommand</code> for testing our web service.</p> <pre><code>      ]load HttpCommand\n</code></pre> </li> <li> <p>Next, download a copy of Jarvis. Note, the following statement downloads the latest, perhaps pre-release, version of the Jarvis class for this quick demonstration. For a production environment, you should use a released version of Jarvis. <code>HttpCommand.Fix</code> both downloads and runs <code>\u2395FIX</code> on an APL code file from the web.</p> <pre><code>      HttpCommand.Fix 'https://raw.githubusercontent.com/Dyalog/Jarvis/master/Source/Jarvis.dyalog'\n</code></pre> </li> <li> <p>Write one or more monadic, result-returning APL functions. For instance:</p> <pre><code>      )cs #\n      sum \u2190 {+/\u2375}                       \u235d dfns work\n      total \u2190 +/                        \u235d derived functions work\n      \u2395FX '\u2207r\u2190addemup a' 'r\u2190+/a' '\u2207'    \u235d and of course, tradfns work\n</code></pre> </li> <li> <p>Next, create an instance of <code>Jarvis</code> using <code>Jarvis.New</code>. </p> <pre><code>      j\u2190Jarvis.New ''\n</code></pre> <p>This will create a <code>Jarvis</code> instance with all settings set to their default values. By default, <code>Jarvis</code> will use port 8080 and look for your endpoint code in <code>#</code>.</p> </li> <li> <p>You can now run your web service running on port 8080 and serving code from the # (root) namespace.  </p> <pre><code>      (rc msg)\u2190j.Start\n2024-09-06 @ 15.46.24.199 - Starting  Jarvis  1.18.1 \n2024-09-06 @ 15.46.24.217 - Conga copied from C:\\Program Files\\Dyalog\\Dyalog APL-64 19.0 Unicode/ws/conga\n2024-09-06 @ 15.46.24.221 - Local Conga v3.5 reference is #.Jarvis.[LIB]\n2024-09-06 @ 15.46.24.231 - Jarvis starting in \"JSON\" mode on port 8080\n2024-09-06 @ 15.46.24.232 - Serving code in #\n2024-09-06 @ 15.46.24.237 - Click http://192.168.001.123:8080 to access web interface\n</code></pre> </li> </ol> <p>If the server started successfully, you'll see messages similar to those above displayed to the APL session and the return code <code>rc</code> should be <code>0</code> and <code>msg</code> should be empty.  If there was any problem starting <code>Jarvis</code>, <code>rc</code> will be non-<code>0</code> and <code>msg</code> will contain a (hopefully) helpful message about the problem that occurred.</p> <p>Now, let's test our service using Jarvis' built-in HTML interface. You could click on the link displayed or open your favorite browser to http://localhost:8080, but just for fun, we'll use Dyalog's HTMLRenderer object.</p> <pre><code>       'h' \u2395WC 'HTMLRenderer' ('URL' 'localhost:8080')\n</code></pre> <p></p> <p>We select the Endpoint (APL function) we want from the drop down list, enter some valid JSON data (<code>[1,3,5]</code>), and press Send to send the request to Jarvis.  Jarvis' response is then sent back and displayed.</p> <p>We can also use <code>HttpCommand</code> to call the web service.</p> <pre><code>      (url data headers)\u2190'localhost:8080/total' '[1,3,5]' ('content-type' 'application/json')\n      (HttpCommand.Do 'POST' url data headers).Data\n9\n</code></pre> <p>We can use the cURL command to call the web service.</p> <pre><code>C:\\&gt; curl -H \"content-type: application/json\" -X POST -d [1,3,5] http://localhost:8080/addemup\n9\n</code></pre> <p>To stop the service, simply type <code>j.Stop</code></p> <p>Interested?  Read on...</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2021 Dyalog</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"concepts/","title":"Conceptual Overview","text":"<p>Jarvis is implemented as a Dyalog APL class. It's okay if you're not familiar with the object oriented features of Dyalog. All you really need to understand is that a Jarvis server is an \"instance\" of the <code>Jarvis</code> class. You create an instance of the class and then configure and run the instance. This is covered in Using Jarvis.</p>"},{"location":"concepts/#terminology","title":"Terminology","text":"<p>Jarvis supports two different \"paradigms\" which define how the client will interact witht the Jarvis service. This section defines some terms that we will use in the discussion below about Jarvis paradigms. </p>"},{"location":"concepts/#client","title":"Client","text":"<p>This is the component sending a request to the Jarvis service and receiving Jarvis' response. The client can be anything that can send HTTP requests and receive HTTP responses.  It could be a web browser, a program, an app on a mobile phone, another server, and so on.</p>"},{"location":"concepts/#url-or-uri","title":"URL (or URI)","text":"<p>The URL (Universal Resource Locator) or URI (Universal Resource Identifier) is the address, possibly including query parameters, which is sent to Jarvis. A URL has the general format: <pre><code>[scheme://][userinfo@]host[:port][/path][?query]\n</code></pre> <code>scheme</code> is either <code>http</code> or <code>https</code>. <code>userinfo@</code> is HTTP Basic authentication user credentials if authentication is being used. <code>host</code> is the Jarvis server domain name or IP address. <code>port</code> is the optional port number. It defaults to 80 for <code>http</code> or 443 for <code>https</code>. <code>path</code> is the endpoint for the request. <code>query</code> are the query parameters, if any, for the request.</p>"},{"location":"concepts/#http-method","title":"HTTP method","text":"<p>The HTTP protocol defines several request \"methods\" that a client may use to request the server to perform different operations. When you open a web browser on a URL, the browser is typically using the GET HTTP method to retrieve the requested content. Other HTTP methods include POST, PUT, DELETE, PATCH, and HEAD; each one designed to indicate the operation the server should perform.</p>"},{"location":"concepts/#json","title":"JSON","text":"<p>JSON stands for JavaScript Object Notation and is a flexible notation for representing data arrays and objects. Dyalog APL has a system function, <code>\u2395JSON</code>, which easily converts between JSON and APL arrays/namespaces.</p>"},{"location":"concepts/#rest","title":"REST","text":"<p>REST stands for REpresentational State Transfer and is a design pattern for APIs. An API that follows this design pattern is termed \"RESTful\". When a RESTful API is called, the server will transfer to the client a representation of the state of the requested resource.</p>"},{"location":"concepts/#paradigms","title":"Paradigms","text":"<p>Jarvis supports two operational paradigms that we term JSON and REST. A Jarvis server can run only one paradigm at a time. One of the first decisions you'll need to make when using Jarvis is which web service paradigm to use. The paradigm will determine protocol for how a client will interact with Jarvis. This section provides information to help you decide which paradigm is most appropriate for your application.</p>"},{"location":"concepts/#the-json-paradigm","title":"The JSON paradigm","text":"<p>The JSON paradigm may seem quite natural to the APLer in that the endpoints (functions) take a data argument and return a data result. The argument and result can be as complex as you like, provided that they can be represented using JSON.</p> <ul> <li>The endpoints are the names of APL functions that are called to satisfy the request.  You can specify which functions you want to expose as endpoints for your service to the client.</li> <li>The client uses the HTTP POST method and passes the parameters for the request as JSON in the request body.</li> <li>The payload (body) of the request is automatically converted by Jarvis from JSON to an APL array and passed as the right argument to your function.</li> <li>Your function should return an APL array which Jarvis then converts to JSON and returns to the client in the response.</li> <li>Your application needs to know nothing about JSON, HTTP or web services.</li> </ul>"},{"location":"concepts/#the-rest-paradigm","title":"The REST paradigm","text":"<p>RESTful web services use standard HTTP methods to perform operations on resources.  A resource (endpoint) is the <code>path</code> in the request's URL.  The resource could be a physical resource like a file or a virtual resource that is constructed dynamically by your code. There are several other \"RESTful  design\" principles or constraints, but they are beyond the scope of this document.</p> <ul> <li>Operations are typically implemented corresponding to standard HTTP methods:<ul> <li>GET \u2013 read a resource</li> <li>POST \u2013 create a resource</li> <li>PUT \u2013 update/replace a resource</li> <li>PATCH \u2013 update/modify a resource</li> <li>DELETE \u2013 delete a resource</li> </ul> </li> <li>With Jarvis, you specify which methods you want your service to support.</li> <li>You then implement an APL function with the same name as each method.</li> <li>Resources are specified in the <code>path</code> of the request URL.  </li> <li>Depending on how you design the service API, parameters, if any, can be passed in the URL,  the query string, the body of the request, or some combination thereof.</li> <li>The function you write is passed the request object and it's up to you to parse the URL, payload, headers, and query parameters to determine what to do and what the arguments are.</li> <li>You decide on the content type and format of the payload of the response.  Common response content types for RESTful web services are JSON, XML or HTML.</li> <li>In general, the JSON paradigm is quicker and easier to implement, but a properly implemented REST paradigm </li> </ul>"},{"location":"concepts/#json-contrasted-with-rest","title":"JSON contrasted with REST","text":"<p>In many cases, the same functionality can be implemented using either paradigm.</p> <p>With JSON, endpoints are the names of APL functions that you want to expose with your web service.  You write one APL function per operation you want to perform.</p> <p>With REST, endpoints identify resources and the HTTP method determines the operation to perform on the resource. You write one APL function for each HTTP method your web service will support.</p> <p>To compare the two paradigms, let's imagine you want to retrieve the total of invoice 45 for customer 231.</p>"},{"location":"concepts/#json-example","title":"JSON Example","text":"<p>One way to implement this using the JSON paradigm might be to:</p> <ul> <li>specify that the client should provide the arguments as a JSON object with a \"customer\" element and an \"invoicenum\" element. For this example, it might look like </li> <li>write an APL function called <code>GetInvoiceTotal</code> which would take a namespace as its argument.  The namespace will contain elements named \"customer\" and \"invoice\" <pre><code>       \u2207 namespace\u2190 GetInvoiceTotal namespace;costs\n    [1]   \u235d the namespace argument was created by Jarvis from the JSON object in the request\n    [2]    costs\u2190namespace.customer GetInvoiceItems namespace.invoice \u235d retrieve the invoice item costs pseudo-code\n    [3]    namespace.total\u2190+/costs \u235d insert a total element into the namespace  \n       \u2207\n</code></pre></li> <li>Jarvis will then convert the result, in this case the updated namespace, to JSON <code>{\"customer\":231,\"invoicenum\":45,\"total\":654.32}</code> and return it to the client</li> </ul>"},{"location":"concepts/#rest-example","title":"REST Example","text":"<p>Using the REST paradigm, you might specify a resource like <code>/customer/231/invoice/45/total</code>. Since this is a \"read\" operation, you would use the HTTP GET method to retrieve it. - You would write a function named <code>GET</code> (the same as the HTTP method) which would be passed the HTTP request object. The <code>Endpoint</code> element of the request object will be <code>'/customer/231/invoice/45/total'</code>.  - Your function would need to parse the endpoint to determine what is being requested and then retrieve the information. - Your function would set the content-type for the response payload as well as format the retrieved information and assign it to the payload.</p>"},{"location":"conga/","title":"Jarvis and Conga","text":"<p><code>Jarvis</code> uses Conga, Dyalog's TCP/IP utility library, for communications. In general most of <code>Jarvis</code>' default Conga-related settings can be left unchanged.  The most likely setting you will want to change is the port number.</p> <p><code>Jarvis</code> requires Conga version 3.0 or later. Conga consists of two elements:</p> <ul> <li>Two shared library files whose names begin with \"conga\" and are found in the Dyalog installation folder. The names of the files varies based on the platform they are running on and the specific version of Conga; for instance <code>conga34_64.dll</code> and <code>conga34ssl64.dll</code> are the shared library files for Conga version 3.4 for the 64-bit version of Dyalog for Windows.</li> <li>An APL-based API to communicate with the shared libraries. There are two versions of the API both of which are available in the <code>conga</code> workspace.<ul> <li>A namespace named <code>Conga</code> which was introduced with Conga version 3.0 and implements behavior that makes it easier to run multiple Conga-based utilities in the same workspace. <code>Conga</code> is the recommended API version to use.</li> <li>A namespace named <code>DRC</code> which is retained for backward-compatibility with applications which use earlier versions of Conga. <code>DRC</code> should only be used in an application where backward compatibility is necessary.</li> </ul> </li> </ul> <p>The Conga API looks for a matching version of the shared libraries; as such the version of the API and the shared libraries must be the same. For more information on Conga please refer to the Conga User Guide.</p>"},{"location":"conga/#default-behavior","title":"Default Behavior","text":"<p>When first run, <code>Jarvis</code> will attempt to find or copy the Conga API and then initialize it. <code>Jarvis</code> will attempt to use the <code>Conga</code> version of the API in preference to the <code>DRC</code> version. In general, all of this is transparent to the user.</p> <ul> <li>Look in the current workspace for the Conga API:<ul> <li>First look in the namespace where <code>Jarvis</code> resides for a namespace named either <code>Conga</code> or <code>DRC</code>, in that order.</li> <li>Failing that, look in the root namespace <code>#</code> for a namespace named either <code>Conga</code> or <code>DRC</code>, in that order.</li> </ul> </li> <li>If neither version of the API is found in the current workspace, <code>Jarvis</code> will attempt to copy the API (first <code>Conga</code> then <code>DRC</code>) from the <code>conga</code> workspace. The API is copied into the <code>Jarvis</code> class which means there will be no additional footprint in workspace. <code>Jarvis</code> will attempt to copy the API as follows:<ul> <li>If the <code>DYALOG</code> environment variable exists, use its folder. Otherwise use the folder from the command line used to start Dyalog.</li> <li>If that fails, then attempt to copy from the \"current\" folder as determined by <code>\u22831 \u2395NPARTS ''</code></li> </ul> </li> <li>If the API was found or successfully copied, <code>Jarvis</code> will initialize Conga as follows:<ul> <li>If the <code>Conga</code> version of the API is used, <code>Jarvis</code> will initialize it with a root name of <code>'Jarvis'</code>.</li> <li>If the <code>DRC</code> version of the API is used, <code>Jarvis</code> will simply initialize it. As <code>DRC</code> does not support multiple roots, care should be taken if other Conga-using utilities also reside in the workspace.</li> </ul> </li> <li>If the API was successfully initialized, a reference to the API root can be found in the shared <code>LDRC</code> field.</li> </ul>"},{"location":"conga/#overriding-default-locations","title":"Overriding Default Locations","text":"<p>There are two methods to tell <code>Jarvis</code>'s default behavior, both of which involve setting a shared public field in the <code>Jarvis</code> class.</p> <ul> <li>If you have the <code>Conga</code> namespace in your workspace in other than default locations the <code>Jarvis</code> will search, <code>Jarvis.CongaRef</code> can be used to specify its location. <code>CongaRef</code> can be an actual reference to the namespace or a character array representing the location. For instance: <code>Jarvis.CongaRef\u2190#.Utils.Conga</code> or <code>Jarvis.CongaRef\u2190'#.Utils.Conga'</code> This can be useful when integrating <code>Jarvis</code> into an application that also uses Conga.</li> <li><code>Jarvis.CongaPath</code> can be used to specify the path to the shared library files and optionally the conga workspace. This can be useful when bundling <code>Jarvis</code> in a distributed application. For instance: <code>Jarvis.CongaPath\u2190(\u22831 \u2395NPARTS ''),'/conga/'</code> would tell <code>Jarvis</code> to find the shared libraries in the <code>/conga/</code> subfolder of the current folder.</li> </ul>"},{"location":"conga/#using-other-versions-of-conga","title":"Using Other Versions of Conga","text":"<p>If you need to use a version of Conga other than the one in the Dyalog installation folder, there are two ways to accomplish this:</p> <ul> <li>Put the shared libraries and the <code>conga</code> workspace in a folder and set <code>Jarvis.CongaPath</code> to point to that folder.</li> <li>Put the <code>Conga</code> namespace in your workspace (pointing <code>Jarvis.CongaRef</code>  to it if necessary) and the shared libraries in a folder set <code>Jarvis.CongaPath</code> to point to that folder.</li> </ul>"},{"location":"conga/#multiple-conga-using-components","title":"Multiple Conga-using Components","text":"<p>Conga is used by several Dyalog utilities and packages including Jarvis, HttpCommand, isolate, EWC, and DFS (Dyalog File Server). You might also use it in your application. When you have multiple Conga-using components in your application it is recommended to have a single instance of the <code>Conga</code> namespace which loads the Conga shared libraries once. Each component should then create their own Conga root.</p>"},{"location":"json/","title":"JSON Paradigm","text":"<p>Jarvis's JSON paradigm was developed to make it easy to expose the functionality of your APL application as a web service. The endpoints of your service are simply APL functions that take an array as a right argument and return an error as a result.</p>"},{"location":"json/#how-jarviss-json-mode-works","title":"How Jarvis's JSON mode works","text":""},{"location":"json/#you-write-an-apl-function-for-each-endpoint-of-your-service","title":"You write an APL function for each endpoint of your service","text":"<p>Each endpoint function should at a minimum take an APL array as a right argument and return an APL array as its result. The name of the endpoint is the name of your function - so, it's best to not use characters in your endpoint function names that aren't easily supported in URLs. Your functions should reside in the namespace specified by [`CodeLocation] </p>"},{"location":"json/#the-client-sends-a-request","title":"The client sends a request","text":"<p>It doesn't matter what the client is - it could be a browser, an app on a phone, Dyalog's <code>HttpCommand</code>, curl, or any program capable of sending and receiving HTTP messages. To call one of your service's endpoints, the client's request should:</p> <ul> <li>Specify the </li> <li>Use the HTTP POST method in order to send the request payload.</li> <li>Include a <code>content-type: application/json</code> header in the request's headers. </li> <li>Format its payload as JSON.</li> </ul> <p>Example</p> <p><code>curl -H \"content-type: application/json\" -X POST -d [1,3,5] http://localhost:8080/sum</code></p> <p>Advanced Usage</p> <ul> <li>The <code>AllowGETs</code> setting will enable HTTP GET method to be used as well - by default <code>AllowGETs</code> is disabled. </li> <li>The <code>AllowFormData</code> setting will enable <code>Jarvis</code> to receive payloads that use <code>content-type: multipart/form-data</code> - by default <code>AllowFormData</code> is disabled.</li> </ul>"},{"location":"json/#jarvis-receives-the-request","title":"<code>Jarvis</code> receives the request","text":"<p>When <code>Jarvis</code> receives the request, it verifies that the request is well-formed. If there is a problem parsing the request, <code>Jarvis</code> will respond to the client with a 400-series HTTP status code and message. Assuming the request is well-formed, <code>Jarvis</code> will convert the request's JSON payload to an APL array using <code>\u2395JSON</code>.</p>"},{"location":"json/#jarvis-calls-your-endpoint-function","title":"<code>Jarvis</code> calls your endpoint function","text":"<p><code>Jarvis</code> passes the APL array as the right argument to your endpoint function.  If your function is dyadic or ambivalent, <code>Jarvis</code> will pass the <code>HttpRequest</code> object as the left argument. Your function should return an APL array result.</p> <p>Advanced Usage</p> <p>Jarvis has a few specific places where you can \"inject\" your own APL code to perform actions like additional request validation, authentication, and so on. Two such places are available after <code>Jarvis</code> receives the request, but before calling your endpoint function.  These are:</p> <ul> <li><code>ValidateRequestFn</code> specifies the name of a function to call for every request that <code>Jarvis</code> receives.</li> <li><code>AuthenticateFn</code> specifies the name of a function to call to perform authentication. </li> </ul>"},{"location":"json/#jarvis-sends-the-response-to-the-client","title":"<code>Jarvis</code> sends the response to the client","text":"<p><code>Jarvis</code> will convert the APL array result into JSON format using <code>\u2395JSON\u2360'HighRank' 'Split'</code> and send the JSON back to the client as the payload of the response.</p>"},{"location":"methods-instance/","title":"Instance Methods","text":"<p>Most of <code>Jarvis</code>' instance methods return a return code, <code>rc</code>, and a message, <code>msg</code>.</p> <ul> <li><code>rc</code> is 0 to indicate success, a non-zero value indicates some error or warning condition</li> <li><code>msg</code> is a (hopefully) meaningful message describing the success or error </li> </ul> <p>Below, the methods you are more likely to use are presented first.</p>"},{"location":"methods-instance/#start","title":"<code>Start</code>","text":"Description <code>Start</code> starts or resumes a <code>Jarvis</code> instance. Syntax <code>(rc msg)\u2190j.Start</code> Examples <pre>      j.Start2025-09-01 @ 10.14.54.476 - Starting  Jarvis  1.20.62025-09-01 @ 10.14.54.493 - Conga copied from C:\\Program Files\\Dyalog\\Dyalog APL-64 20.0 Unicode/ws/conga2025-09-01 @ 10.14.54.494 - Local Conga v3.6 reference is #.Jarvis.[LIB]2025-09-01 @ 10.14.54.499 - Jarvis starting in \"JSON\" mode on port 80802025-09-01 @ 10.14.54.500 - Serving code in #2025-09-01 @ 10.14.54.506 - Click http://192.168.223.137:8080 to access web interface0  Server started</pre>"},{"location":"methods-instance/#stop","title":"<code>Stop</code>","text":"Description <code>Stop</code> stops a running <code>Jarvis</code> instance. Syntax <code>(rc msg)\u2190j.Stop</code> Examples <pre>      j.Stop2025-09-01 @ 10.54.24.701 - Stopping server...0  Server stopped      j.Stop \u235d try stopping a stopped server\u00af1  Server is not running </pre>"},{"location":"methods-instance/#config","title":"<code>Config</code>","text":"Description <code>Config</code> returns all of the settings for a <code>Jarvis</code> instance. Syntax <code>r\u2190j.Config</code> <code>r</code> is a 2-column matrix of <code>[;1]</code> setting names, <code>[;2]</code> setting values. Examples <pre>       j.Config AcceptFrom AllowFormData                                               0  AllowGETs                                                   0  AppCloseFn AppInitFn AuthenticateFn BufferSize                                              10000  CORS_Headers                                                *  CORS_MaxAge                                                60  CORS_Methods                                 GET,POST,OPTIONS  ORS_Origin                                                 *  ... and so on and so forth</pre> Notes At present, there are about 60 settings that are displayed."},{"location":"methods-instance/#endpoints","title":"<code>EndPoints</code>","text":"Description Syntax `` Examples Notes"},{"location":"methods-instance/#pause","title":"<code>Pause</code>","text":"Description <code>Pause</code> \"pauses\" a running <code>Jarvis</code> instance. Pausing causes <code>Jarvis</code> to refuse any new connections. Existing connections will continue to be served. The <code>Start</code> method will \"unpause\" a paused <code>Jarvis</code>. Syntax <code>(rc msg)\u2190j.Pause</code> Examples <pre>      j.Pause2025-09-01 @ 10.57.13.275 - Pausing server...0  Server paused       j.Pause \u235d try pausing a paused server\u00af2  Server is already paused       j.Start \u235d restart a paused server2025-09-01 @ 11.03.31.296 - Starting  Jarvis  1.20.60  Server resuming operations       j.Stop2025-09-01 @ 10.58.36.630 - Stopping server...0  Server stopped       j.Pause \u235d try pausing a stopped server\u00af1  Server is not running </pre> Notes"},{"location":"methods-instance/#running","title":"<code>Running</code>","text":"Description <code>Running</code> returns a <code>1</code> if <code>Jarvis</code> is running or paused, <code>0</code> otherwise. Syntax <code>r\u2190j.Running</code>"},{"location":"methods-instance/#thread","title":"<code>Thread</code>","text":"Description <code>Thread</code> returns the thread number if the server is running or <code>\u236c</code> if the server is not running. Syntax <code>thread\u2190j.Thread</code>"},{"location":"methods-instance/#log","title":"<code>Log</code>","text":"Description <code>Log</code> is an overridable method used to log messages. By default if <code>Logging</code> is set to <code>1</code> the message passed as the right argument is displayed with a timestamp in the APL session. Syntax <code>{msg}\u2190{level}Log msg</code> <code>msg</code> The message to be displayed. This is also returned as the shy result. <code>level</code> (optional) The message level. This is not used in the default <code>Log</code> method, but is included so that an overriding method can make use of it to distinguish between different types of messages, for instance informational, warning, and error messages. Examples To use <code>Log</code> from an endpoint, you need to use the reference to the <code>Jarvis</code> server that is supplied in the Request object. One might write something like<pre>req.server.Log 'Endpoint \"',(\u2283\u2395SI),'\" called'</pre> to log whenever an endpoint is called. Notes We intend to implement more comprehensive logging in a future release of Jarvis."},{"location":"methods-instance/#reset","title":"<code>Reset</code>","text":"Description <code>Reset</code> \"resets\" <code>Jarvis</code> by killing all <code>Jarvis</code>-related threads and clearing any session information. <code>Reset</code> does not affect any <code>Jarvis</code> settings. Syntax <code>(rc msg)\u2190j.Reset</code> Examples <pre>      j.Reset0  Server reset (previously set options are still in effect)</pre> Notes <code>Reset</code> is rarely needed but can be useful during endpoint development."},{"location":"methods-shared/","title":"Shared Methods","text":""},{"location":"methods-shared/#new","title":"<code>New</code>","text":"Description <code>New</code> creates a new instance of the Jarvis class. Syntax <code>j\u2190Jarvis.New args</code> <code>args</code> One of:<ul><li><code>''</code> - create a Jarvis instance with the default configuration</li><li>a character vector full path name to one of<ul><li>a JSON or JSON5 file containing a JarvisConfig definition</li><li>a file containing a namespace or class script that will be loaded as CodeLocation</li><li>a folder containing files with code that will be loaded into <code>j.CodeLocation</code></li></ul><li>a reference to a namespace containing named Jarvis configuration settings</li><li>a vector of up to 4 positional settings<ul><li><code>Port</code></li><li><code>CodeLocation</code></li><li>Paradigm</li><li><code>JarvisConfig</code></li></ul></li> <code>j</code> A reference to the newly created Jarvis instance Examples <code>j\u2190Jarvis.New 5000 #.MyEndpoints</code> Notes With the introduction of APL Array Notation in Dyalog v20.0, namespace arguments are made even more convenient, for example: <code>j\u2190Jarvis.New (Paradigm:'REST'\u22c4Port:12345)</code>"},{"location":"methods-shared/#documentation","title":"<code>Documentation</code>","text":"Description <code>Documentation</code> displays a link to the online Jarvis documentation. Syntax <code>Jarvis.Documentation</code> Example <code>Jarvis.Documentation</code><code>See https://dyalog.github.io/Jarvis</code>"},{"location":"methods-shared/#version","title":"<code>Version</code>","text":"Description <code>Version</code> returns the <code>Jarvis</code> version Syntax <code>(what version date)\u2190Jarvis.Version</code> <code>what</code> is <code>'Jarvis'</code> <code>version</code> is the version number. For example: <code>'1.20.5'</code> <code>date</code> is the date when this version was created. For example: <code>'2025-08-17'</code>"},{"location":"methods-shared/#run","title":"<code>Run</code>","text":"Description <code>Run</code> creates a new instance of the Jarvis class using <code>Jarvis.New</code> and then calling the instance's <code>Start</code>  method to start it. Syntax <code>(j (rc msg))\u2190Jarvis.Run args</code> <code>args</code> One of:<ul><li><code>''</code> - create a Jarvis instance with the default configuration</li><li>a character vector full path name to one of<ul><li>a JSON or JSON5 file containing a JarvisConfig definition</li><li>a file containing a namespace or class script that will be loaded as CodeLocation</li><li>a folder containing files with code that will be loaded into <code>j.CodeLocation</code></li></ul><li>a reference to a namespace containing named Jarvis configuration settings</li><li>a vector of up to 4 positional settings<ul><li><code>Port</code></li><li><code>CodeLocation</code></li><li>Paradigm</li><li><code>JarvisConfig</code></li></ul></li> <code>(j (rc msg)</code> <code>j</code> is a reference to the newly created Jarvis instance created by <code>New</code><code>rc</code> and <code>msg</code> are the return code and message from <code>Start</code> Examples <code>(j (rc msg))\u2190Jarvis.New 5000 #.MyEndpoints</code> Notes <code>Run</code> was primarily developed as a shortcut method for demos. The recommended technique is to call <code>New</code>, then make any additional configuration changes, and then call <code>Start</code> and check <code>rc</code> to verify that <code>Jarvis</code> was started."},{"location":"methods-shared/#myaddr","title":"<code>MyAddr</code>","text":"Description <code>MyAddr</code> returns your machine's IP address on the local network. Syntax <code>addr\u2190Jarvis.MyAddr</code> Examples <code>Jarvis.MyAddr</code><code>192.168.1.223</code>"},{"location":"request/","title":"Request Object","text":"<p>A <code>Request</code> object is created for each request <code>Jarvis</code> receives from a client. <code>Request</code> contains the information from the HTTP request and a <code>Response</code> namespace that contains information <code>Jarvis</code> uses to send the response back to the client.  <code>Request</code> is also passed as an argument to several of <code>Jarvis</code>' \"hook\" functions. </p> <p>We'll use <code>req</code> in the documentation and examples to refer to an instance of the <code>Request</code> object.</p>"},{"location":"request/#when-using-the-json-paradigm","title":"When using the JSON paradigm","text":"<p><code>req</code> is passed as the left argument to dyadic or ambivalent endpoints. In many cases, your endpoint won't need the <code>Request</code>; <code>Jarvis</code> handles the details of formatting the response from the result of your endpoint.   </p>"},{"location":"request/#when-using-the-rest-paradigm","title":"When using the REST paradigm","text":"<p>The <code>Request</code> object is passed as the right argument to your HTTP command handlers.</p>"},{"location":"request/#request-fields","title":"<code>Request</code> Fields","text":"<p>Most <code>Request</code> fields should be considered read-only and are intended to convey information about the request to your endpoints.</p>"},{"location":"request/#contenttype","title":"<code>ContentType</code>","text":"Description <code>ContentType</code> is the request's payload content type specified in the <code>content-type</code> header. <code>charset</code> contains any <code>charset</code> specified in the <code>content-type header</code>. Default <code>''</code>"},{"location":"request/#charset","title":"<code>Charset</code>","text":"Description <code>Charset</code> is the character set, if any, specified in the <code>content-type</code> header. Default <code>''</code> Notes If <code>Charset</code> is <code>'utf-8'</code>, <code>Jarvis</code> will do the proper UTF-8 conversion to the request payload."},{"location":"request/#body","title":"<code>Body</code>","text":"Description <code>Body</code> is the raw body of the request after any UTF-8 conversion, if needed. Default <code>''</code> Notes The difference between <code>Body</code> and <code>Payload</code> is that <code>Payload</code> will have undergone any appropriate translation whereas <code>Body</code> won't. For example, if the <code>ContentType</code> is <code>'application/json'</code>, <code>Body</code> might be <code>[1,2,3]</code> whereas <code>Payload</code> would be the APL array <code>1 2 3</code>. Similarly, if the <code>ContentType</code> is <code>'multipart/form-data'</code> or <code>'application/x-www-form-urlencoded'</code>, <code>Body</code> contain the raw character data whereas <code>Payload</code> will be a namespace containing the named elements specified in the <code>Body</code>."},{"location":"request/#endpoint","title":"<code>Endpoint</code>","text":"Description <code>Endpoint</code> is the endpoint specified in the request's URL, without any query string. Default <code>''</code> Notes In JSON mode, <code>Endpoint</code> is the name of the function that will be called when servicing the request."},{"location":"request/#headers","title":"<code>Headers</code>","text":"Description <code>Headers</code> is a 2-column matrix of the request's <code>[;1]</code> header names, <code>[;2]</code> header values. Default <code>0 2\u2374'' ''</code> Notes The <code>GetHeader</code> method can be used to retrieve header values by name."},{"location":"request/#method","title":"<code>Method</code>","text":"Description <code>Method</code> is the HTTP method used for the request. Default <code>''</code> Notes In JSON mode, this will normally be <code>POST</code>. In REST mode, the HTTP method specifies the function to be called to service the request as specified in <code>RESTMethods</code>."},{"location":"request/#password","title":"<code>Password</code>","text":"Description Default Example(s) Notes"},{"location":"request/#userid","title":"<code>UserID</code>","text":"Description Default Example(s) Notes"},{"location":"request/#peercert","title":"<code>PeerCert</code>","text":"Description Default Example(s) Notes"},{"location":"request/#peeraddr","title":"<code>PeerAddr</code>","text":"Description Default Example(s) Notes"},{"location":"request/#server","title":"<code>Server</code>","text":"Description Default Example(s) Notes"},{"location":"request/#session","title":"<code>Session</code>","text":"Description Default Example(s) Notes"},{"location":"request/#killondisconnect","title":"<code>KillOnDisconnect</code>","text":"Description Default Example(s) Notes"},{"location":"request/#input","title":"<code>Input</code>","text":"Description Default Example(s) Notes"},{"location":"request/#payload","title":"<code>Payload</code>","text":"Description Default Example(s) Notes"},{"location":"request/#response","title":"<code>Response</code>","text":"<p>See <code>Response</code> Namespace.</p>"},{"location":"request/#request-methods","title":"<code>Request</code> Methods","text":""},{"location":"request/#response-namespace","title":"<code>Response</code> Namespace","text":""},{"location":"rest/","title":"REST Paradigm","text":"<p>Jarvis's REST paradigm was developed to make it possible to deploy your APL application using a REST API. REST APIs are more applicable when managing a collection of resources. HTTP-based REST web services, like Jarvis, use standard HTTP methods (GET, POST, PUT, DELETE, etc) to create, retrieve, and manipulate resources.</p> <p>There are six guiding principles of REST. The degree to which you adhere to these principles is completely up to you.</p>"},{"location":"rest/#how-jarviss-rest-mode-works","title":"How Jarvis's REST mode works","text":""},{"location":"rest/#you-write-an-apl-function-for-each-http-method-your-service-will-support","title":"You write an APL function for each HTTP method your service will support","text":"<p>Rather than writing a function for each endpoint as in the JSON paradigm, you will write a monadic function for each of the HTTP methods that your web service will support. Your functions should reside in the namespace specified by <code>CodeLocation</code>. </p> <p>You specify which HTTP methods your REST service will support using the <code>RESTMethods</code> setting. For instance, setting <code>RESTMethods\u2190'Get'</code> indicates that your service will support only HTTP GET requests. Such requests will call the <code>#.CodeLocation.Get</code> function, passing the HTTP request as its right argument. For the purposes of this document, we'll call the request right argument <code>Request</code>.</p> <p>Your <code>Get</code> function would then look at the resource being requested by parsing <code>Request.Endpoint</code> element. If <code>DefaultContentType</code> is set to <code>'application/json'</code> (the default), your function can return an APL array which <code>Jarvis</code> will convert to JSON. If you are not using <code>'application/json'</code>, then you will need to:</p> <ol> <li>use <code>Request.SetContentType</code> to set an appropriate content type</li> <li>set the <code>Request.Response.Payload</code> to the content you want to send back to the client</li> </ol>"},{"location":"rest/#the-client-sends-a-request","title":"The client sends a request","text":"<p>It doesn't matter what the client is - it could be a browser, an app on a phone, Dyalog's <code>HttpCommand</code>, curl, or any program capable of sending and receiving HTTP messages. To interact with a resource, the client should:</p> <ul> <li>Specify the resource in the request URL</li> <li>Specify the HTTP method appropriate to the operation being requested</li> <li>If the request includes a payload, specify an appropriate <code>content-type</code> header </li> </ul> <p>Example</p> <p>To retrieve a hypothetical list of orders for customer with id 123, one might make a request like:  <code>resp\u2190HttpCommand.Get 'http://localhost:8080/customers/123/orders'</code></p>"},{"location":"rest/#jarvis-receives-the-request","title":"<code>Jarvis</code> receives the request","text":"<p>When <code>Jarvis</code> receives the request, it verifies that the request is well-formed. If there is a problem parsing the request, <code>Jarvis</code> will respond to the client with a 400-series HTTP status code and message.</p>"},{"location":"rest/#jarvis-calls-your-method-function","title":"<code>Jarvis</code> calls your method function","text":"<p><code>Jarvis</code> passes the <code>Request</code> object as the right argument to the function appropriate for the HTTP method being used. It is up to your function to parse <code>Request.Endpoint</code> to determine the resource being requested. As noted above, if the response payload's <code>content-type</code> is <code>'application/json'</code> your function can return an APL array which <code>Jarvis</code> will automatically convert to JSON. Otherwise, your function is responsible for setting the <code>Request.Response.Payload</code> and <code>Request.ContentType</code> appropriately.</p> <p>If the requested resource is not found, or some other issue occurs, your function should fail the request with an appropriate HTTP status code using <code>Request.Fail</code>. For example, an HTTP status code of 404 means that the requested resource was not found and you would use <code>Request.Fall 404</code> to set the status code.</p> <p>Advanced Usage</p> <p>Jarvis has a few specific places where you can \"inject\" your own APL code to perform actions like additional request validation, authentication, and so on. Two such places are available after <code>Jarvis</code> receives the request, but before calling your function.  These are:</p> <ul> <li><code>ValidateRequestFn</code> specifies the name of a function to call for every request that <code>Jarvis</code> receives.</li> <li><code>AuthenticateFn</code> specified the name of a function to call to perform authentication. </li> </ul>"},{"location":"rest/#jarvis-sends-the-response-to-the-client","title":"<code>Jarvis</code> sends the response to the client","text":"<p><code>Jarvis</code> will format a proper HTTP response and send it to the client.</p>"},{"location":"settings-conga/","title":"Conga-Related Settings","text":"<p>Jarvis uses Conga for TCP/IP communications. <code>Jarvis</code>'s Conga settings are used to configure the Conga's operation. In most cases <code>Jarvis</code>' default Conga-settings are sufficient. See the Conga User Guide for more detailed information on specific settings. See Jarvis and Conga if your application has other components that also use Conga, such as HttpCommand or isolates, or if you are using Conga that is not located in the Dyalog installation folder. </p> <p>Once started, <code>Jarvis</code> maintains a reference to to Conga library in the shared <code>LDRC</code> setting. This enables you to manage query and/or manage Conga settings directly if you need to.  For instance, <code>j.LDRC.Tree '.'</code> will return the entire Conga object tree.</p> <p><code>Jarvis</code> has two shared Conga-related settings - <code>CongaPath</code> and <code>CongaRef</code>.</p>"},{"location":"settings-conga/#acceptfrom","title":"<code>AcceptFrom</code>","text":"Description <code>AcceptFrom</code> allows you to limit <code>Jarvis</code> incoming connections to a specific set of IP address ranges. <code>AcceptFrom</code> is either one or two character vectors that specify IPV4 and/or IPV6 address ranges. Each vector is a comma-delimited set of IP ranges. Default <code>''</code> Examples <code>j.AcceptFrom\u2190'192.168.1.1/127,10.17.221.67/75'</code> Notes This setting is documented as <code>AllowEndPoints</code> in the Conga User Guide. Unlike <code>AllowEndPoints</code>, you do not need to specify <code>'IPV4'</code> or <code>'IPV6'</code> as <code>Jarvis</code> can automatically determine which IP version is intended."},{"location":"settings-conga/#buffersize","title":"<code>BufferSize</code>","text":"Description <code>BufferSize</code> specifies the maximum HTTP headers length that <code>Jarvis</code> will accept. The intent is to block malicious requests that attempt to overwhelm the server by sending huge requests. Default <code>10000</code> Examples <code>j.BufferSize\u21905000 \u235d allow up to 5000 bytes of HTTP header data</code> Notes <code>BufferSize</code> can be used in conjunction with <code>DOSLimit</code> to mitigate Denial of Service (DOS) attacks."},{"location":"settings-conga/#denyfrom","title":"<code>DenyFrom</code>","text":"Description Similar to <code>AcceptFrom</code>, <code>DenyFrom</code> allows you to deny incoming connections from a specific set of IP address ranges. <code>DenyFrom</code> is either one or two character vectors that specify IPV4 and/or IPV6 address ranges. Each vector is a comma-delimited set of IP ranges. Default <code>''</code> Examples <code>j.DenyFrom\u2190'192.168.1.1/127,10.17.221.67/75'</code> Notes This setting is documented as <code>DenyEndPoints</code> in the Conga User Guide. Unlike <code>DenyEndPoints</code>, you do not need to specify <code>'IPV4'</code> or <code>'IPV6'</code> as <code>Jarvis</code> can automatically determine which IP version is intended."},{"location":"settings-conga/#doslimit","title":"<code>DOSLimit</code>","text":"Description To reduce possible Denial Of Service (DOS) attacks, <code>DOSLimit</code> is used to limit the size of HTTP payloads that <code>Jarvis</code> will accept. Default <code>\u00af1</code> which indicates to use the Conga default value of 10485760 Examples <code>j.DOSLimit\u2190100000 \u235d assumes no message will exceed 100000 bytes</code> Notes You should specify a <code>DOSLimit</code> large enough to accept the largest message you anticipate receiving."},{"location":"settings-conga/#fifo","title":"<code>FIFO</code>","text":"Description <code>FIFO</code> controls how Conga will process incoming requests. Setting <code>FIFO</code> to <code>1</code> will cause Conga to process requests in a \"First In, First Out\" order. Setting <code>FIFO</code> to <code>0</code> will cause Conga to process requests according to Conga's <code>ReadyStrategy</code> setting. Default <code>1</code> Examples <code>j.FIFO\u21900 \u235d turn FIFO mode off</code> Notes This setting is documented as <code>EnableFifo</code> in the Conga User Guide."},{"location":"settings-conga/#port","title":"<code>Port</code>","text":"Description <code>Port</code> is port number that <code>Jarvis</code> will listen on. Default <code>8080</code> Examples <code>j.Port\u219022361</code> Notes Allocating ports below 1024 on Linux typically requires root privileges due to security reasons."},{"location":"settings-conga/#rootcertdir","title":"<code>RootCertDir</code>","text":"Description When running <code>Jarvis</code> over HTTPS, <code>RootCertDir</code> is the path to a folder containing public root certificates. Default <code>''</code> Examples Set <code>RootCertDir</code> to the public root certificates folder installed with Dyalog.<code>dir\u21901 1\u22831 \u2395NPARTS 2 \u2395NQ '.' 'GetCommandLineArgs'</code><code>j.RootCertDir\u2190dir,'PublicCACerts'</code> Notes This setting is documented as <code>RootCertDir</code> in the Conga User Guide. See <code>Security</code> for more information."},{"location":"settings-conga/#priority","title":"<code>Priority</code>","text":"Description <code>Priority</code> is the GnuTLS priority string when using secure communications. <code>Priority</code> specifies the TLS session's handshake algorithms when negotiating a secure connection. Default 'NORMAL:!CTYPE-OPENPGP' Examples <code>j.Priority\u2190'NORMAL:-MD5' \u235d use the default without HMAC-MD5</code> Notes Setting <code>Priority</code> to something other than the default requires an in-depth understanding of TLS session negotiation. Don't change it unless you know know what you're doing."},{"location":"settings-conga/#secure","title":"<code>Secure</code>","text":"Description <code>Secure</code> is a Boolean setting that controls whether <code>Jarvis</code> will use TLS. Valid settings are:<ul><li><code>0</code> - do not use TLS</li><li><code>1</code> - attempt to use TSL (see notes below)</li></ul> Default <code>0</code> Examples <code>j.Secure\u21901 \u235d enable secure communications</code> Notes Using TLS requires configuring several settings, see Using TLS."},{"location":"settings-conga/#servercertski","title":"<code>ServerCertSKI</code>","text":"Description Under Windows, when using the Microsoft Certificate Store to obtain the server certificate for <code>Jarvis</code> to use, <code>ServerCertSKI</code> is the Server Certificate Subject Key Identifier of the certificate. Default <code>''</code> Examples <code>j.ServerCertSKI\u2190'aca7d8f00691129ea0bc3613a00ed8ea9a5e55f5'</code> Notes The subject key identifier is a 40 byte hexadecimal string. For more information, see Using TLS."},{"location":"settings-conga/#servercertfile","title":"<code>ServerCertFile</code>","text":"Description <code>ServerCertFile</code> is the name of the file containing the server's public certificate. Default <code>''</code> Examples <code>j.ServerCertFile\u2190'/etc/mycerts/publiccert.pem'</code> Notes For more information, see Using TLS."},{"location":"settings-conga/#serverkeyfile","title":"<code>ServerKeyFile</code>","text":"Description <code>ServerKeyFile</code> is the name of the file containing the server's private key. Default <code>''</code> Examples <code>j.ServerKeyFile\u2190'/etc/mycerts/privatekey.pem'</code> Notes Never share your private key file. For more information, see Using TLS."},{"location":"settings-conga/#servername","title":"<code>ServerName</code>","text":"Description <code>ServerName</code> is the Conga name for the <code>Jarvis</code> server. You can specify the name or have it Conga assign it. Default Assigned by Conga in the format <code>'SRVnnnnnnnn'</code> where <code>nnnnnnnn</code> begins at <code>00000000</code> and is incremented when a <code>Jarvis</code> server using the same Conga instance is started. Examples <code>)copy conga Conga</code> <code>j1\u2190Jarvis.New 8080</code> <code>j2\u2190Jarvis.New 8081</code> <code>j3\u2190Jarvis.New 8082</code> <code>j3.ServerName\u2190'MyJarvis'</code> <code>(j1 j2 j3).Start</code> <code>(j1 j2 j3).ServerName</code><code>SRV00000000  SRV00000001  MyJarvis</code> Notes <code>ServerName</code> can be useful when interacting with Conga, particularly when debugging. For example: <code>j3.(LDRC.Describe ServerName)</code><code>0   MyJarvis  Server  Listen</code><code>LDRC</code> is <code>Jarvis</code>'s local reference to the Conga library."},{"location":"settings-conga/#sslvalidation","title":"<code>SSLValidation</code>","text":"Description <code>SSLValidation</code> is employed as part of the certificate checking process and is more fully documented in the Conga User Guide. Default <code>64</code> - request but do not require a client certificate Examples <code>j.SSLValidation\u2190128 \u235d require a valid certificate</code> Notes For more information, see Using TLS."},{"location":"settings-conga/#waittimeout","title":"<code>WaitTimeout</code>","text":"Description <code>WaitTimeout</code> is the number of milliseconds that <code>Jarvis</code> will wait in its listening loop before timing out. Default <code>15000</code> - 15 seconds Examples <code>j.WaitTimeout\u219060000 \u235d wait a minute before timing out</code> Notes Conga servers sit in a \"wait\" loop listening for communications from clients. If no communications occur before <code>WaitTimeout</code> has passed, Conga will signal a \"Timeout\" event and reiterate the \"wait\" loop."},{"location":"settings-container/","title":"Container Settings","text":"<p>Most Jarvis configuration options should be set using a Jarvis configuration file. A few environment variables are particularly useful in the context of running Jarvis in a container.</p>"},{"location":"settings-container/#dyalog_jarvis_port","title":"<code>DYALOG_JARVIS_PORT</code>","text":"Description If set, <code>DYALOG_JARVIS_PORT</code> is the port that the Jarvis container will listen on. It overrides both the <code>Jarvis</code> default and any port specified in the <code>Jarvis</code> configuration. Default <code>''</code> Examples <code>DYALOG_JARVIS_PORT=8888</code> Notes <code>DYALOG_JARVIS_PORT</code> allows you to specify different port numbers for each instance of the Jarvis container."},{"location":"settings-container/#dyalog_jarvis_codelocation","title":"<code>DYALOG_JARVIS_CODELOCATION</code>","text":"Description If set, <code>DYALOG_JARVIS_CODELOCATION</code> is the path to a folder containing your <code>Jarvis</code> endpoint code. Default <code>''</code> Examples <code>DYALOG_JARVIS_CODELOCATION=/myJarvisApp</code>"},{"location":"settings-container/#dyalog_jarvis_thread","title":"<code>DYALOG_JARVIS_THREAD</code>","text":"Description <code>DYALOG_JARVIS_THREAD</code> controls which thread <code>Jarvis</code> will run on. Valid values are:<ul><li><code>0</code> - run in thread 0</li><li><code>1</code> - run in a separate thread, use <code>\u2395TSYNC</code> to wait for result from <code>Server</code> thereby preventing from starting and then immediately signing off</li><li><code>'debug'</code> - run in a separate thread, return thread 0 to immediate execution</li><li><code>''</code> or <code>'auto'</code> - if running with an interactive terminal, use <code>'debug'</code> otherwise use <code>1</code></li></ul> Default <code>''</code> Examples <code>DYALOG_JARVIS_THREAD=1</code> Notes If you need to debug your Jarvis service in a container, you can configure Dyalog to use RIDE and set <code>DYALOG_JARVIS_THREAD</code> to any of <code>debug</code>, <code>''</code> or <code>'auto'</code> to remotely access your Jarvis service."},{"location":"settings-cors/","title":"CORS Settings","text":"<p>CORS, or Cross-Origin Resource Sharing, is a security feature implemented by web browsers to control how resources on a web page can be requested from another domain outside the domain from which the resource originated. It helps prevent malicious websites from accessing sensitive data on other websites.</p> <p>When a web page makes a request to a different domain (cross-origin request), the browser checks if the server allows such requests by looking at the CORS headers in the server's response. If the headers indicate that the request is allowed, the browser permits the resource to be accessed; otherwise, it blocks the request.</p> <p>CORS is essential for enabling secure communication between different web applications and APIs while protecting users from potential security risks.</p> <p>Without modification, Jarvis's default CORS settings will allow most CORS requests. For more information about CORS, see CORS.</p>"},{"location":"settings-cors/#enablecors","title":"<code>EnableCORS</code>","text":"Description <code>EnableCORS</code> is a Boolean setting which enables or disables CORS support in <code>Jarvis</code>. Valid values are:<ul><li><code>0</code> - disable CORS support</li><li><code>1</code> - enable CORS support</li></ul> Default <code>1</code> Examples <code>j.EnableCORS\u21900 \u235d disable CORS support</code>"},{"location":"settings-cors/#cors_origin","title":"<code>CORS_Origin</code>","text":"Description <code>CORS_Origin</code> specifies the domains from which requests are allowed. Valid values are:<ul><li><code>'*'</code> to allow requests from all domains</li><li><code>1</code> - to \"reflect\" whatever origin is specified in the request's \"origin\" header</li><li>a domain from which requests will be accepted</li></ul> Default <code>'*'</code> - requests from all domains are allowed. Examples <code>j.CORS_Origin\u2190'https://foo.example' \u235d allow requests only from https://foo.example</code>"},{"location":"settings-cors/#cors_methods","title":"<code>CORS_Methods</code>","text":"Description <code>CORS_Methods</code> controls which HTTP methods that will be allowed in cross-origin requests. Valid values are:<ul><li><code>\u00af1</code>which means <code>Jarvis</code> will allow HTTP methods based on the paradigm being used:<ul><li>JSON - <code>'GET,POST,OPTIONS'</code></li><li>REST - whatever methods you have specified in <code>RESTMethods</code></li></ul></li><li><code>1</code> which means allow the method specified in the request's <code>Access-Control-Request-Method</code> header</li><li>a comma-delimited list of methods to allow.</li></ul> Default <code>\u00af1</code> Examples <code>j.CORS_Methods\u2190'GET,POST'</code> Notes This setting applies only to preflighted requests. You may also directly set the <code>Access-Control-Allow-Methods</code> header, which will override the <code>CORS_Methods</code> setting."},{"location":"settings-cors/#cors_headers","title":"<code>CORS_Headers</code>","text":"Description <code>CORS_Headers</code> controls what additional headers will be allowed in a CORS request. Valid values are:<ul><li><code>'*'</code> which means any headers will be allowed</li><li><code>1</code> which will allow any header names specified in the request's <code>Access-Control-Request-Headers</code> header </li><li>a string of comma-delimited header names</li></ul> is a comma-delimited string specifies what additional HTTP response headers will be exposed Default <code>'*'</code> Examples <code>j.CORS_Headers\u2190'X-Custom-Header'</code> Notes By default, only the CORS-safelisted response headers are exposed to the client. This setting applies only to preflighted requests. You may also directly set the <code>Access-Control-Allow-Headers</code> header, which will override the <code>CORS_Headers</code> setting."},{"location":"settings-cors/#cors_maxage","title":"<code>CORS_MaxAge</code>","text":"Description <code>CORS_MaxAge</code> indicates, in seconds, how long the results of a preflight request can be cached. Default <code>60</code> Examples <code>j.CORS_MaxAge\u2190600 \u235d set to 10 minutes (600 seconds)</code> Notes This setting applies only to preflighted requests. You may also directly set the <code>Access-Control-Max-Age</code> header, which will override the <code>CORS_MaxAge</code> setting."},{"location":"settings-hooks/","title":"User Hooks Settings","text":"<p>\"Hook\" functions are functions you write to inject custom behavior at specific points in <code>Jarvis</code>'s execution. You then assign the name of the function to the appropriate \"hook\". Hook functions can be located in <code>#.CodeLocation</code> - <code>Jarvis</code> will exclude them from being considered as endpoint functions. By default, no hook functions are defined; you need to define only the hook functions, if any, that are needed for your web service.</p>"},{"location":"settings-hooks/#appclosefn","title":"<code>AppCloseFn</code>","text":"Description <code>AppCloseFn</code> is the name of the niladic, function to be called when <code>Jarvis</code> is stopped. This function could do things like closing database connections, managing log files, etc. The function may return a 2-element array of <code>(rc msg)</code> where <code>rc</code> is an integer return code (<code>0</code> means \"okay\") and <code>msg</code> is a character vector message. If the function does not return a result, the <code>Jarvis</code> will return the return code and message that was set prior to calling <code>AppCloseFn</code>. Default <code>''</code> Examples <code>j.AppCloseFn\u2190'ShutDown'</code>"},{"location":"settings-hooks/#appinitfn","title":"<code>AppInitFn</code>","text":"Description <code>AppInitFn</code> is the name of the monadic, result-returning function to be called when <code>Jarvis</code> is started. This function is called before <code>Jarvis</code> starts listening for requests. This function could do things like establishing database connections or other application initialization. The function should return a 2-element array of <code>(rc msg)</code> where <code>rc</code> is an integer return code (<code>0</code> means \"okay\") and <code>msg</code> is a character vector message. If the function is monadic, its right argument is a reference to the <code>Jarvis</code> instance. Default <code>''</code> Examples <code>j.AppInitFn\u2190'Startup'</code> Notes If your function returns a non-<code>0</code> return code, <code>Jarvis</code> will exit."},{"location":"settings-hooks/#authenticatefn","title":"<code>AuthenticateFn</code>","text":"Description <code>AuthenticateFn</code> is the name of monadic, result-returning function to be called when you need to authenticate a request. The right argument to the function is the <code>Request</code> instance. The function result should either be:<ul><li><code>0</code> - meaning that authentication was successful or that no authentication was necessary for this request</li><li><code>1</code> = meaning that authentication failed in which case <code>Jarvis</code> will fail the request with an HTTP status code of 401 (Unauthorized).</li></ul> Default <code>''</code> Examples <code>j.AuthenticateFn\u2190'Authenticate'</code> Notes See Authentication for more information about how to authenticate an HTTP request."},{"location":"settings-hooks/#postprocessfn","title":"<code>PostProcessFn</code>","text":"Description <code>PostProcessFn</code> is the name of monadic, non-result-returning function to be called after your endpoint has run but before the response is sent to the client. The right argument to the function is the <code>Request</code> instance. The function should not return a result however, if it does, that result is ignored.If you have some treatment that you need to apply to every response, <code>PostProcessFn</code> can be used to avoid having to add that treatment to every endpoint. Default <code>''</code> Examples <code>j.PostProcessFn\u2190'PostProcess'</code> <code>\u2207 PostProcess req</code><code>[1]    'custom-header'req.SetHeader'some value' \u235d add a custom header</code><code>[2]    req.Reponse.Payload.Message\u2190'Have a nice day!' \u235d modify the payload</code> <code>\u2207</code>"},{"location":"settings-hooks/#sessioninitfn","title":"<code>SessionInitFn</code>","text":"Description <code>SessionInitFn</code> is the name of a monadic, result-returning function that can perform session initialization if your web service is using sessions. The right argument is the <code>Request</code> instance, which we'll call <code>req</code>. The reference to the session namespace is <code>req.Session</code>. The integer function result should be either:<ul><li><code>0</code> - indicating that the session was successfully initialized</li><li>non-<code>0</code> - indicating session initialization failed; in which case <code>Jarvis</code> will fail the request with an HTTP status code of 500 ().</li></ul> Default <code>''</code> Examples <code>j.SessionInitFn\u2190'InitSession</code> Notes See Using Sessions for more information."},{"location":"settings-hooks/#validaterequestfn","title":"<code>ValidateRequestFn</code>","text":"Description <code>ValidateRequestFn</code> is the name of a monadic, result-returning function that will be called for every request that <code>Jarvis</code> receives. <code>ValidateRequestFn</code> gives you the opportunity to perform additional validation on a request. The right argument is the <code>Request</code> instance. The function result should either be:<ul><li><code>0</code> - meaning that validation was successful or that no validation was necessary for this request</li><li><code>1</code> = meaning that validation failed in which case <code>Jarvis</code> will fail the request with an HTTP status code of 400 (Bad Request).</li></ul> Default <code>''</code> Examples <code>j.ValidateRequestFn\u2190'Validate'</code> Notes See Validation for more information."},{"location":"settings-json/","title":"JSON Settings","text":"<p>These settings apply when using Jarvis's JSON paradigm.</p>"},{"location":"settings-json/#allowformdata","title":"<code>AllowFormData</code>","text":"Description <code>AllowFormData</code> controls whether <code>Jarvis</code> will accept requests with a content-type of <code>'multipart/form-data'</code>. This makes it more convenient when using a form in a web browser as the client or to upload a file. Valid settings are:<ul><li><code>1</code> - allow content-type <code>'multipart/form-data'</code></li><li><code>0</code> - Do not allow content-type <code>'multipart/form-data'</code> Default <code>0</code> Examples <code>j.AllowFormData\u21901 \u235d enable multipart/form-data content</code>"},{"location":"settings-json/#allowgets","title":"<code>AllowGETs</code>","text":"Description <code>AllowGETs</code> controls whether <code>Jarvis</code> will accept HTTP GET requests to call endpoints. Normally, <code>Jarvis</code> will accept only HTTP POST requests to access an endpoint, but there may be cases when it's convenient to all simple requests using HTTP GET. Valid settings are:<ul><li><code>0</code> - do not allow HTTP GET requests</li><li><code>1</code> - allow HTTP GET requests</li></ul> Default <code>0</code> Examples <code>j.AllowGETs\u21901 \u235d accept GET requests</code> Notes Parameters to the endpoint being called should be specified using URL-encoded properly formatted JSON in the URL query string.  For instance, if you have a <code>sum\u2190+/</code> endpoint and you want to sum the array <code>[1,2,3]</code>, you would need to use the endpoint and query string <code>/sum?%5B1%2C2%2C3%5D</code> (which is URL-encoded <code>/sum?[1,2,3]</code>)."},{"location":"settings-json/#htmlinterface","title":"<code>HTMLInterface</code>","text":"Description <code>HTMLInterface</code> controls whether and how <code>Jarvis</code> will provide an HTML interface. Valid settings are:<ul><li><code>0</code> - do not enable the HTML interface</li><li><code>1</code> - enable the Jarvis's built-in HTML interface</li><li><code>'path'</code> - a character vector naming a folder (or file) that contains the HTML content to serve. If <code>'path'</code> is a folder name, <code>Jarvis</code> will look for a file named \"index.html\" in that folder.</li><li><code>'' 'function'</code> - where <code>function</code> is the name of a monadic, result-returning function. The function is passed the <code>Request</code> object and should return HTML content. Default <code>1</code> if using JSON mode, <code>0</code> otherwise Examples <code>j.HTMLInterface\u2190'/myjarvis/web/' \u235d HTML content is in the folder /myjarvis/web/</code>"},{"location":"settings-json/#jsoninputformat","title":"<code>JSONInputFormat</code>","text":"Description <code>JSONInputFormat</code> controls the format of the request's JSON payload when converted to APL. Valid settings are:<ul><li><code>'D'</code> - return the payload as data</li><li><code>'M'</code> - return the payload in a matrix format.</li></ul>These settings are the same as the <code>'Format</code>' option for <code>\u2395JSON</code>. Default <code>D</code> Examples <code>j.JSONInputFormat\u2190'M' \u235d use the matrix inport format for \u2395JSON</code> Notes <code>JSONInputFormat</code> also has effect when using Jarvis<code>s REST paradigm if [</code>ParsePayload<code>](./settings-rest.md#parsepayload) is set to</code>1`."},{"location":"settings-json/#report404inhtml","title":"<code>Report404InHTML</code>","text":"Description When a requested endpoint is not found, <code>Jarvis</code> will always respond by setting the response HTTP status code to <code>404</code> and HTTP status message to <code>'Not Found'</code>.  <code>Report404InHTML</code> controls whether <code>Jarvis</code> will also return a simple \"not found\" HTML page in its response payload. This is potentially useful when the client is a web browser. Valid settings are:<ul><li><code>1</code> - return a simple HTML page in the response payload indicating the requested endpoint was not found.  This is useful when the client connecting to <code>Jarvis</code> is a web browser.</li><li><code>0</code> - Do not return any information in the response payload. Default <code>1</code> Examples <code>j.Report404\u21900 \u235d disable sending the \"not found\" HTML page</code> Notes <code>Report404InHTML</code> has effect only if the <code>HTMLInterface</code> is enabled."},{"location":"settings-operational/","title":"Operational Settings","text":""},{"location":"settings-operational/#codelocation","title":"<code>CodeLocation</code>","text":"Description Prior to starting a <code>Jarvis</code> instance, <code>CodeLocation</code> specifies where <code>Jarvis</code> will look for your endpoint code. <code>CodeLocation</code> can be any of:<ul><li>The name of or a reference to an existing namespace that contains your endpoint code.</li><li>A file path to a folder that contains your endpoint code. In this case, <code>Jarvis</code> will load the contents of the folder into the namespace <code>#.CodeLocation</code>, similar to how LINK works.</li><li>The name of a file containing a namespace definition. In this case, <code>Jarvis</code> will use <code>\u2395FIX</code> to load the namespace into <code>#</code> and set <code>CodeLocation</code> to a reference to the loaded namespace.</li></ul>After starting, <code>CodeLocation</code> is set to a reference to the namespace containing your endpoint code. Default <code>'#'</code> Examples <code>j.CodeLocation\u2190#.myEndpoints               \u235d reference to namespace</code> <code>j.CodeLocation\u2190'#.myEndpoints'             \u235d name of namespace</code><code>j.Codelocation\u2190'/home/me/myEndpoints'      \u235d folder</code><code>j.CodeLocation\u2190'/home/me/myEndpoints.apln' \u235d file containing namespace definition</code> Notes If the environment variable <code>DYALOG_JARVIS_CODELOCATION</code> exists, it will override any other setting for <code>CodeLocation</code>."},{"location":"settings-operational/#connectiontimeout","title":"<code>ConnectionTimeout</code>","text":"Description <code>ConnectionTimeout</code> specifies the the amount of time in seconds that a connection may be idle before being closed. <code>Jarvis</code> will not close a connection that is currently being serviced by a long-running endpoint. Default <code>30</code> Examples <code>j.ConnectionTimeout\u2190120 \u235d 2 minute timeout</code> Notes <code>ConnectionTimeout</code> is used by <code>Jarvis</code>'s \"housekeeping\" to prevent inactive connections from accumulating."},{"location":"settings-operational/#debug","title":"<code>Debug</code>","text":"Description Setting <code>Debug</code> to a non-zero value will enable various types of debugging and reporting to take place. The valid values for <code>Debug</code> are:<ul><li><code>0</code> - all errors are trapped</li><li><code>1</code> - stop when an untrapped error occurs in either the endpoint code or the Jarvis framework itself.</li><li><code>2</code> - <code>Jarvis</code> will stop execution on the thread handling a request prior to any application code being executed.  This enables the user to debug their code \"in situ\".</li><li><code>4</code> - <code>Jarvis</code> will stop execution on the thread handling a request once the the request is completely received. This is used mostly for tracing and debugging Jarvis itself.</li><li><code>8</code> - <code>Jarvis</code> will display Conga events other than <code>'Timeout'</code> to the APL session.</li><li><code>16</code> - <code>Jarvis</code> will stop execution immediately before sending the response to the client.</li></ul><code>Debug</code> values are additive. For example <code>9</code> (<code>1+8</code>) would stop on any error as well as enable Conga event reporting. Default <code>0</code> Examples <code>j.Debug\u21902 \u235d stop just before executing any user code</code> Notes While it is possible to set <code>Debug</code> to <code>\u00af1</code> to enable all forms of debugging, be mindful that additional values for <code>Debug</code> may be added in the future and this could lead to unintended behavior."},{"location":"settings-operational/#defaultcontenttype","title":"<code>DefaultContentType</code>","text":"Description <code>DefaultContentType</code> specifies the HTTP content-type for <code>Jarvis</code>'s response if no content-type header has been specified by the user's endpoint code. Default <code>'application/json; charset=utf-8'</code> Examples <code>j.DefaultContentType\u2190'application/xml; charset=utf-8'</code> Notes <code>DefaultContentType</code> should only be set when most of the responses from your endpoints will have a content-type other than <code>'application/json'</code>. For individual responses that use a different content-type, set <code>request.ContentType</code>."},{"location":"settings-operational/#errorlevelinfo","title":"<code>ErrorLevelInfo</code>","text":"Description <code>ErrorLevelInfo</code> specifies how much information to include in the HTTP status message when an untrapped error occurs and <code>Jarvis</code> returns an HTTP status code of 500. Valid settings are:<ul><li><code>0</code> - do not include any information about the error</li><li><code>1</code> - include the APL error name (for example <code>VALUE ERROR</code>)</li><li><code>2</code> - include the function and line number where the error occurred.</li></ul> Default <code>1</code> Examples <code>j.ErrorInfoLevel\u21902 \u235d include function name and line number</code>"},{"location":"settings-operational/#hostname","title":"<code>Hostname</code>","text":"Description <code>Hostname</code> is the name of the host that <code>Jarvis</code> will insert into the \"host\" header of the response. If a response payload from <code>Jarvis</code> needs to include URLs pointing to other endpoints within the service, <code>Hostname</code> can be used to construct those URLS. Default <code>''</code> which means that <code>Jarvis</code> will use the result of <code>2 \u2395NQ # 'TCPGetHostID'</code> (the IP address of the server on the local network) Examples <code>j.Hostname\u2190'www.myJarvis.com'</code> Notes <code>2 \u2395NQ # 'TCPGetHostID'</code> returns the IP address on the local network, which isn't of much use if the client is accessing <code>Jarvis</code> from an external network. <code>Hostame</code> exists to address this problem by providing an external address to <code>Jarvis</code>."},{"location":"settings-operational/#httpauthentication","title":"<code>HTTPAuthentication</code>","text":"Description <code>HTTPAuthentication</code> indicates the HTTP authentication scheme that will be used to authenticate requests. Currently only HTTP Basic authentication is supported. Valid settings are:<ul><li><code>'basic'</code> to enable HTTP Basic authentication</li><li><code>''</code> to disable HTTP Basic authentication. Default <code>'basic'</code> Examples <code>j.HTTPAuthentication\u2190'' \u235d disable HTTP basic authentication</code> Notes See HTTP Basic Authentication"},{"location":"settings-operational/#jarvisconfig","title":"<code>JarvisConfig</code>","text":"Description <code>JarvisConfig</code> is the name of the JSON (or JSON5) file, if any, that contains your Jarvis configuration. Default <code>''</code> Examples <code>j.JarvisConfig\u2190'/home/myapp/jarvisconfig.json</code> Notes If you specify a relative path to the Jarvis configuration file, <code>Jarvis</code> will consider it to be relative to the current working directory as returned by <code>1 \u2395NPARTS ''</code>"},{"location":"settings-operational/#loadablefiles","title":"<code>LoadableFiles</code>","text":"Description If <code>CodeLocation</code> specifies a folder from which to load your endpoints' code, <code>LoadableFiles</code> specifies a comma-delimited set of patterns to match when selecting files to load into workspace. Default <code>'*.apl?,*.dyalog'</code> Examples <code>j.LoadableFiles\u2190'*.apln,*.aplf,*.aplc'</code> Notes Dyalog has evolved its \"code in files\" methodology. In its early days, the <code>.dyalog</code> extension was used almost exclusively. Over time, and with the advent of <code>Link</code>, the common practice is to the use of file extension to indicate the particular type of APL object contained within the file - <code>.aplf</code> for a function, <code>.apln</code> for a namespace, <code>.aplc</code> for a class, and <code>.apla</code> for an array."},{"location":"settings-operational/#logging","title":"<code>Logging</code>","text":"Description <code>Logging</code> is a Boolean setting that determines whether <code>Jarvis</code> will display certain internal log messages to the session. Default <code>1</code> Examples <code>j\u2190Jarvis.New ''</code> <code>j.Start \u235d default is Logging\u21901</code><code>2024-12-06 @ 11.34.23.890 - Starting  Jarvis  1.18.4</code><code>2024-12-06 @ 11.34.23.913 - Conga copied from C:\\Program Files\\Dyalog\\Dyalog APL-64 19.0 Unicode/ws/conga</code><code>2024-12-06 @ 11.34.23.915 - Local Conga v3.5 reference is #.Jarvis.[LIB]</code><code>2024-12-06 @ 11.34.23.923 - Jarvis starting in \"JSON\" mode on port 8080</code><code>2024-12-06 @ 11.34.23.927 - Serving code in #</code><code>2024-12-06 @ 11.34.23.931 - Click http://192.168.223.134:8080 to access web interface</code><code>0  Server started</code> <code>j.Stop</code><code>2024-12-06 @ 11.34.35.564 - Stopping server...</code><code>0  Server stopped</code> <code>j.Logging\u21900 \u235d turn off logging</code> <code>j.Start</code><code>0  Server started</code> Notes The messages controlled by <code>Logging</code> are internal, operational, messages.Request and HTTP logging capabilities will be available in a forthcoming Jarvis release."},{"location":"settings-operational/#paradigm","title":"<code>Paradigm</code>","text":"Description <code>Paradigm</code> specifies the mode in which <code>Jarvis</code> will operate. Current valid values are:<ul><li><code>'JSON'</code> to use the JSON Paradign</li><li><code>'REST</code>' to use the REST Paradigm</li></ul> Default <code>'JSON</code> Examples <code>j.Paradigm\u2190'REST'</code> Notes You should set <code>Paradigm</code> before starting your <code>Jarvis</code> instance."},{"location":"settings-operational/#usezip","title":"<code>UseZip</code>","text":"Description <code>UseZip</code> is a Boolean that tells <code>Jarvis</code> whether to send a compressed response payload if the client will accept it as indicated by the \"accept-encoding\" header in the client request. Valid values are:<ul><li><code>0</code> - do not compress the response payload</li><li><code>1</code> use either \"gzip\" or \"deflate\" compression if the client will accept them Default <code>0</code> Examples <code>j.UseZip\u21901</code> Notes At present only \"gzip\" and \"deflate\" content-encodings are supported. <code>ZipLevel</code> controls the level of compression employed."},{"location":"settings-operational/#ziplevel","title":"<code>ZipLevel</code>","text":"Description <code>ZipLevel</code> is an integer value between 0 and 9 and specifies the level of compression to use when <code>Jarvis</code> compresses the response payload (see <code>UseZip</code>). Higher values result in a higher degree of compression albeit at the cost of performance. Default <code>3</code> which seems to provide the best trade-off of compression versus speed. Examples <code>j.ZipLevel\u21906</code>"},{"location":"settings-overview/","title":"Settings Overview","text":"<p>The settings documentation is broken up into groups of related settings as follows.</p> Group Description Operational Settings related to the operation of the <code>Jarvis</code> server. Examples include <code>CodeLocation</code>, <code>JarvisConfig</code> and <code>Paradigm</code>. Conga Settings specific to Conga, Dyalog's TCP/IP framework. JSON Mode Settings specific to running a Jarvis service in JSON mode. REST Mode Settings specific to running a Jarvis service in REST mode. Session Settings related to using sessions with <code>Jarvis</code> to maintain server-side state. User Hooks Settings that allow you to specify \"hook\" functions to perform tasks like application initialization, session initialization, and authentication. Container Settings related to running a Jarvis service in a containerized environment like Docker. CORS Settings related to Cross Origin Resource Sharing which can enable calls to your Jarvis service to be made from webpages in other domains. Shared Settings that are shared by all instances of Jarvis."},{"location":"settings-rest/","title":"REST Settings","text":"<p>These settings apply when using Jarvis's REST paradigm.</p>"},{"location":"settings-rest/#parsepayload","title":"<code>ParsePayload</code>","text":"Description <code>ParsePayload</code> controls whether <code>Jarvis</code> automatically convert JSON and XML request payload to an APL format using either <code>\u2395JSON</code> or <code>\u2395XML</code> as appropriate.Valid settings are:<ul><li><code>1</code> - convert JSON and/or XML payloads</li><li><code>0</code> - do not convert JSON and/or XML payloads</li></ul> Default <code>1</code> - parse JSON and XML payloads Examples <code>j.ParsePayload\u21900 \u235d do not parse JSON and XML payloads</code> Notes The format for parsed JSON payloads is controlled by <code>JSONInputFormat</code>."},{"location":"settings-rest/#restmethods","title":"<code>RESTMethods</code>","text":"Description <code>RESTMethods</code> specifies which HTTP methods will be supported by your REST web service. It is a comma-delimited character vector of HTTP method names and optionally, the name of the APL function that will service that HTTP method. Each comma-delimited segment consists of a case-insensitive HTTP method name (<code>'get' 'GET' 'gEt'</code> will all match GET). The method name can be optionally followed by a <code>'/'</code> and the function name which implements the handler for that HTTP method. If no function name is supplied, the function name will be the case-sensitive HTTP method. Default <code>'Get,Post,Put,Delete,Patch,Options'</code> Examples <code>j.RESTMethods\u2190'Get,post/handlePOST'</code>In this example our service will accept HTTP GET and POST requests.<ul><li>GET requests will be by a function named <code>Get</code></li><li>POST requests will be handled by a function called <code>handlePOST</code>.</li></ul> Notes Jarvis does not place a restriction on the HTTP method names, meaning that you could potentially invent your own \"HTTP\" methods.<code>j.RESTMethods\u2190'Get,Bloofo' \u235d allow GET and BLOOFO</code>."},{"location":"settings-session/","title":"Session Settings","text":"<p>A stateless web service means that each request from a client to the server is treated as an independent transaction that is unrelated to any previous request. In other words, the server does not store any information about the state of the client between requests. There are many good reasons for implementing a stateless web service including improved scalability, reliability, and independence. However, in some cases it may make sense to maintain some state on the server. Jarvis's sessions are intended to allow you to maintain state in the server.</p> <p>See Using Sessions for more information.</p>"},{"location":"settings-session/#sessiontimeout","title":"<code>SessionTimeout</code>","text":"Description <code>SessionTimeout</code> controls whether <code>Jarvis</code> will use sessions. It also specifies how long before a session will time out and be removed. Valid settings are:<ul><li><code>0</code> - do not use sessions</li><li><code>n</code> - the number of minutes of inactivity before a session is timed out and removed</li><li><code>\u00af1</code> - use sessions without any timeout. In this case it is up to your code to manage any session timeouts.</li></ul> Default <code>0</code> - do not use sessions Examples <code>j.SessionTimeout\u219010 \u235d timeout after 10 minutes of inactivity</code>"},{"location":"settings-session/#sessionidheader","title":"<code>SessionIdHeader</code>","text":"Description <code>SessionIdHeader</code> is the name of the HTTP header or HTTP cookie that will contain the session identifier. Every sessioned request must include this session ID in order to access the session state information on the server. Default <code>'Jarvis-SessionID'</code> Examples <code>j.SessionIdHeader\u2190'gandalf'</code>"},{"location":"settings-session/#sessionusecookie","title":"<code>SessionUseCookie</code>","text":"Description <code>SessionUseCookie</code> controls whether the session id is sent using an HTTP header or an HTTP cookie. In either case, the header or the cookie name will be specified by <code>SessionIdHeader</code>. Valid settings are:<ul><li><code>0</code> - use the HTTP header instead of a cookie</li><li><code>1</code> - use an HTTP cookie instead of the header Default <code>0</code> Examples <code>j.SessionUseCookie\u21901 \u235d use a cookie for the session id</code> Notes Using an HTTP cookie can be more convenient, especially if the client is a browser. When <code>Jarvis</code> creates session it will send the cookie in its response and then the browser will automatically include the cookie in every subsequent request."},{"location":"settings-session/#sessionpollingtime","title":"<code>SessionPollingTime</code>","text":"Description <code>SessionPollingTime</code> controls how often, in minutes, <code>Jarvis</code> polls for timed-out sessions. Default <code>1</code> Examples <code>j.SessionPollingTime\u21905</code> Notes When using sessions, <code>Jarvis</code> starts a session monitor in a separate thread. The session monitor loops continuously checking for timed-out sessions. <code>SessionPollingTime</code> controls the time between each loop."},{"location":"settings-session/#sessioncleanuptime","title":"<code>SessionCleanupTime</code>","text":"Description <code>SessionCleanupTime</code> controls how often, in minutes, <code>Jarvis</code> purges remaining information about timed-out sessions. Default <code>60</code> Examples <code>j.(SessionCleanupTime\u2190SessionTimeout) \u235d set to not retain any information after a session times out</code> Notes When a session times out, <code>Jarvis</code> erases the namespace associated with the session, but leaves information about the session having existed. <code>SessionCleanupTime</code> determines when that remaining information is removed. The intent was to give you the opportunity to inform the client that their session timed out if they send a request after the session has timed out, but before the remaining information is expunged."},{"location":"settings-shared/","title":"Shared Settings","text":"<p>Shared settings are shared between all instances of <code>Jarvis</code> in the workspace.</p>"},{"location":"settings-shared/#ldrc","title":"<code>LDRC</code>","text":"Description <code>LDRC</code> is a reference to the initialized Conga library. It can be used to access Conga functions. See the Conga User Guide for more information on Conga's functions. Default <code>LDRC</code> is initially <code>''</code> and is set by <code>Jarvis</code> to the Conga library reference upon initialization. Examples <code>j.LDRC.Names '.'</code> Notes You should not attempt to set <code>LDRC</code> yourself."},{"location":"settings-shared/#congapath","title":"<code>CongaPath</code>","text":"Description <code>CongaPath</code> is a pathname to the folder pathname used to tell <code>Jarvis</code> where to look for either the Conga workspace or the Conga shared libraries. Default <code>''</code> Examples <code>Jarvis.CongaPath\u2190'c:\\myapp\\Conga\\'</code> Notes See Jarvis and Conga for more information."},{"location":"settings-shared/#congaref","title":"<code>CongaRef</code>","text":"Description <code>CongaRef</code> is a name of or reference to the <code>Conga</code> namespace in workspace. Default <code>''</code> Examples <code>Jarvis.CongaRef\u2190#.MyApp.Conga</code> Notes See Jarvis and Conga for more information"},{"location":"using-request/","title":"Using the Request Object","text":"<p>A <code>Request</code> object is created for every HTTP request that <code>Jarvis</code> receives. It contains information about the request - HTTP headers, HTTP cookies, the client's IP address, certificate information (if you're using HTTPS), etc. It also contains the <code>Response</code> namespace which will have the information to format <code>Jarvis</code>' response.</p> <p><code>Request</code> is also passed as an argument to several of the \"hook\" functions.</p>"},{"location":"using-request/#simple-authentication-example","title":"Simple Authentication Example","text":"<p>If your <code>Jarvis</code> service used HTTP Basic, <code>Jarvis</code> will populate the <code>Userid</code> and <code>Password</code> fields with the credentials supplied in the request. In this example we'll use a somewhat nonsensical validation of checking if the <code>Password</code> is the reverse of the <code>Userid</code> <pre><code>     \u2207 rc\u2190Authenticate req\n[1]   \u235d Perform simple silly HTTP Basic authentication example\n[2]   \u235d check that:\n[3]   \u235d   there is a UserID\n[4]   \u235d   the Password is the reverse of UserID\n[5]   \u235d req - the request object\n[6]   \u235d rc  - 0 if authentication passes, 1 otherwise\n[7]    \u21920\u2374\u2368rc\u21900\u220a\u2374req.UserID        \u235d fail if UserID is empty\n[8]    rc\u2190req.UserID\u2262\u233dreq.Password \u235d fail if UserID is not the reverse of Password\n     \u2207\n</code></pre> or more succinctly <code>Authenticate\u2190{0\u220a\u2374\u2375.UserID:1 \u22c4 \u2375.UserID\u2262\u233d\u2375.Password}</code></p>"},{"location":"using-request/#manipulating-the-requests-response","title":"Manipulating the Request's Response","text":"<p><code>Jarvis</code> will assume that all responses are of the content-type specified by <code>DefaultContentType</code> which has a default setting of <code>'application/json; charset=utf-8'</code>. You can specify a different <code>DefaultContentType</code> if most or all of your endpoints return response payloads other than JSON. You can also set the content-type in your endpoint code by using the request's <code>SetContentType</code> method. For example:</p> <p><pre><code>     \u2207 r\u2190req ReturnHTML string\n[1]   \u235d Simple example of manipulating the payload\n[2]    req.SetContentType'text/html; charset=utf-8'\n[3]    r\u2190'&lt;h1&gt;',string,'&lt;/h1&gt;'\n     \u2207\n</code></pre> If you are sending files in the response payload, you can spe</p>"},{"location":"using/","title":"Using Jarvis","text":""},{"location":"using/#best-practices","title":"Best Practices","text":"<p>For all but the simplest of Jarvis-based services, we recommend:</p> <ul> <li>Store the code that implements your endpoints in text files which Jarvis will load upon startup. Set the <code>CodeLocation</code> configuration setting to the folder name that contains the text files.</li> <li>Use a Jarvis configuration file to specify all non-default configuration settings. </li> </ul>"},{"location":"using/#core-usage-pattern","title":"Core Usage Pattern","text":"<p>There are four basic steps to running a Jarvis service.</p> <ol> <li>Write the APL code which implements the endpoints of your service.</li> <li>Create an instance of the <code>Jarvis</code> class.</li> <li>Configure the instance.</li> <li>Run the instance.</li> </ol> <p>Everything else - from running the service locally to deploying it as a secure, cloud-hosted, load-balanced service is built on upon these four steps.</p>"},{"location":"using/#write-the-apl-code-that-implements-the-endpoints","title":"Write the APL code that implements the endpoints","text":"<p>The Jarvis paradigm you choose (JSON or REST) will determine how to write your endpoints.</p> <ul> <li>JSON - you will write an APL function to implement each endpoint. The function name is the endpoint name.  See the JSON Paradigm section for more information.</li> <li>REST - you will write an APL function for each HTTP method your service will support.  The function name is the same as the HTTP method name. See the REST Paradigm section for more information.</li> </ul>"},{"location":"using/#create-an-instance-of-the-jarvis-class","title":"Create an instance of the <code>Jarvis</code> class","text":"<p>While you can use the <code>\u2395NEW</code> system function to create an instance of <code>Jarvis</code>, the recommended technique is to use <code>Jarvis.New</code>.</p> <p><code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j\u2190Jarvis.New args</code></p> <p><code>args</code> can be one of:</p> <ul> <li><code>''</code> - create the instance using the default settings. Any non-default settings that you plan to use will need to be set before starting the instance.</li> <li><code>'path-to-a-Jarvis-config-file'</code> - create the instance using the settings specified in a Jarvis config file. A Jarvis config file is a JSON (or JSON5) file that contains Jarvis configuration settings.</li> <li><code>namespace-reference</code> - create the instance using the named settings contained in a namespace. The namespace can contain only variables with names of Jarvis configuration settings.</li> <li>A positional vector of up to 4 elements containing <code>Port CodeLocation 'Paradigm' 'JarvisConfig'</code>.  You do not need to provide all parameters - only those up to the last parameter you need to use.  For instance, if you need to specify <code>'REST'</code> as the paradigm, you'll also need to supply <code>Port</code> and <code>CodeLocation</code>.   </li> </ul> <p>Note that you can always set additional configuration settings after creating the instance with any of the above methods (but before running the instance).</p> <p>Assuming that the file <code>/JarvisConfig.json</code> contains: <code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\"Port\":80, \"CodeLocation\":\"/myJarvisApp/\", \"Paradigm\":\"REST\"}</code> and <code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0namespace\u2190\u2395JSON \u2283\u2395NGET '/JarvisConfig.json'</code> the following are equivalent. <pre><code>j\u2190Jarvis.New '' \u22c4 j.(Port CodeLocation Paradigm)\u219080 '/myJarvisApp' 'REST'\nj\u2190Jarvis.New '/JarvisConfig.json'\nj\u2190Jarvis.New namespace\nj\u2190Jarvis.New 80 '/myJarvisApp/' 'REST'\n</code></pre></p>"},{"location":"using/#codelocation","title":"<code>CodeLocation</code>","text":"<p><code>CodeLocation</code> specifies where Jarvis should look for the code that implements your endpoints. It can be</p> <ul> <li>a reference to, or the name of, a namespace in the workspace. For example, either <code>#.MyApp</code> and <code>'#.MyApp'</code> will work if your application code is in the namespace <code>#.MyApp</code>.</li> <li>a character vector representing the path to the folder that contains your application code.  If the path is relative, Jarvis attempts to determine the root folder from which to the path is relative to what it's relative to as follows:<ul> <li>If Jarvis is running in a saved workspace, it uses the folder where the workspace is located.</li> <li>Otherwise, if you have specified a Jarvis config file, Jarvis will use the folder where the config file is located.</li> <li>Otherwise, if Jarvis can determine the path for its source file, it will use that.</li> <li>Finally, it will default to the current folder for your Dyalog session as determined by  <code>(1 \u2395NPARTS '')</code>.  Using a relative path can be useful for making your Jarvis service more portable, but it's important to make sure to understand the process above. For instance, if you have been running Jarvis from a <code>CLEAR WS</code> by dynamically loading it and then you save your application to a named workspace, Jarvis could wind up looking in a potentially different folder if the workspace is stored elsewhere than the Jarvis config file.</li> </ul> </li> </ul>"},{"location":"using/#configure-the-jarvis-instance","title":"Configure the <code>Jarvis</code> instance","text":"<p>Having created a <code>Jarvis</code> instance, you can set any configuration parameter prior to starting the instance.  This includes being able to override parameters that may have been loaded from a Jarvis config file. Details about each of the parameters can be found in Settings.</p>"},{"location":"using/#run-the-jarvis-instance","title":"Run the <code>Jarvis</code> instance","text":"<p>Use <code>j.Start</code> to start the <code>Jarvis</code> instance. Use <code>j.Stop</code> to stop <code>Jarvis</code>. You can run <code>j.Start</code> again to restart <code>Jarvis</code>. </p>"}]}